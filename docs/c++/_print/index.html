<!doctype html>
<html lang="zh-cn" class="no-js">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="generator" content="Hugo 0.92.2" />
<link rel="canonical" type="text/html" href="https://lowerce.github.io/docs/c&#43;&#43;/">
<link rel="alternate" type="application/rss&#43;xml" href="https://lowerce.github.io/docs/c&#43;&#43;/index.xml">
<meta name="robots" content="noindex, nofollow">


<link rel="shortcut icon" href="/favicons/favicon.ico" >
<link rel="apple-touch-icon" href="/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="icon" type="image/png" href="/favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/favicons/android-36x36.png" sizes="36x36">
<link rel="icon" type="image/png" href="/favicons/android-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="/favicons/android-72x72.png" sizes="72x72">
<link rel="icon" type="image/png" href="/favicons/android-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/favicons/android-144x144.png" sizes="144x144">
<link rel="icon" type="image/png" href="/favicons/android-192x192.png" sizes="192x192">

<title>C&#43;&#43; | Lowerce&#39;s Wiki Blog</title>
<meta name="description" content="C&#43;&#43;相关的学习笔记.
">
<meta property="og:title" content="C&#43;&#43;" />
<meta property="og:description" content="C&#43;&#43;相关的学习笔记.
" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://lowerce.github.io/docs/c&#43;&#43;/" /><meta property="og:site_name" content="Lowerce&#39;s Wiki Blog" />

<meta itemprop="name" content="C&#43;&#43;">
<meta itemprop="description" content="C&#43;&#43;相关的学习笔记.
"><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43;"/>
<meta name="twitter:description" content="C&#43;&#43;相关的学习笔记.
"/>




<link rel="preload" href="/scss/main.min.704093cd1a56f37fd00dc35c7125fced09d88d60c92d59965b30c8c0eeef1cd5.css" as="style">
<link href="/scss/main.min.704093cd1a56f37fd00dc35c7125fced09d88d60c92d59965b30c8c0eeef1cd5.css" rel="stylesheet" integrity="">

<script
  src="https://code.jquery.com/jquery-3.5.1.min.js"
  integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
  crossorigin="anonymous"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-JK76XTWHST"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-JK76XTWHST', { 'anonymize_ip': false });
}
</script>

  </head>
  <body class="td-section">
    <header>
      
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar">
        <a class="navbar-brand" href="/">
		<span class="navbar-logo"></span><span class="text-uppercase font-weight-bold">Lowerce&#39;s Wiki Blog</span>
	</a>
	<div class="td-navbar-nav-scroll ml-md-auto" id="main_navbar">
		<ul class="navbar-nav mt-2 mt-lg-0">
			
			
			<li class="nav-item mr-4 mb-2 mb-lg-0">
				
				
				
				
				
				
				
				
				<a class="nav-link" href="/about/" ><span>About</span></a>
			</li>
			
			<li class="nav-item mr-4 mb-2 mb-lg-0">
				
				
				
				
				
				
				
				
				<a class="nav-link active" href="/docs/" ><span class="active">Notes</span></a>
			</li>
			
			<li class="nav-item mr-4 mb-2 mb-lg-0">
				
				
				
				
				
				
				
				
				<a class="nav-link" href="/blog/" ><span>Blog</span></a>
			</li>
			
			
			
		</ul>
	</div>
	<div class="navbar-nav d-none d-lg-block"><input type="search" class="form-control td-search-input" placeholder="&#xf002; 站内搜索…" aria-label="站内搜索…" autocomplete="off">
</div>
</nav>

    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <main class="col-12 col-md-9 col-xl-8 pl-md-5" role="main">
            




<div class="td-content">
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href="#" onclick="print();return false;">点击此处打印</a>.
</p><p>
<a href="/docs/c&#43;&#43;/">返回本页常规视图</a>.
</p>
</div>



<h1 class="title">C&#43;&#43;</h1>
<div class="lead">C++相关的学习笔记.</div>




    <ul>
    
  
  
  
  

  
    
    
	
<li>1: <a href="#pg-49671f503b21c7485647046edee33eae">C&#43;&#43;疑点难点</a></li>


    
  
    
    
	
<li>2: <a href="#pg-451807a610c5be94feb9cac83b376571">C&#43;&#43; Primer</a></li>


    
  

    </ul>


<div class="content">
      
</div>
</div>


  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-49671f503b21c7485647046edee33eae">1 - C&#43;&#43;疑点难点</h1>
    
	<p>UP:HexUp
30 分钟讲明白现代 C++最重要的特性之一：智能指针</p>
<h3 id="类型声明">类型声明</h3>
<p>遵循“右左”法则
从<strong>变量名</strong>开始向右看 看完后向左看
不可忽略括号 即一层层括号地看
跳出一层后的外层表示的是内层元素的类型或者内层指针的指向
读取过程的顺序表示后者是前者元素的类型
<strong>const</strong>一类的声明也遵从“右左”法则</p>
<h3 id="指针大小">指针大小</h3>
<p>32位（Bit）架构和64位（Bit）架构
内存的最小单位 1字节（Byte）=8 Bit
32Bit程序的指针大小 4字节
64Bit程序的指针大小 8字节
指针大小在本质上由<strong>编译器</strong>决定</p>
<h3 id="lambda表达式">Lambda表达式</h3>
<p>又名<strong>闭包</strong>
结构：
<code>[ 捕获变量 ]( 参数列表 ) -&gt; 返回类型 { 函数主体 }</code>
变量捕获时不加<code>&amp;</code>按值捕获，加<code>&amp;</code>按引用捕获
<code>[&amp;]</code>按引用捕获所有外部变量
<code>[=]</code>按值捕获所有外部变量
上述二者可以结合，<code>[&amp;,=N]</code>除了变量<code>N</code>按值捕获外其他外部变量全部按引用捕获</p>
<h3 id="裸指针与动态内存分配">裸指针与动态内存分配</h3>
<p><code>new</code>用来动态申请内存
<code>delete</code>用来手动释放动态申请的内存，否则这部分内存不会被释放，如果<code>new</code>申请的空间为数组，需要使用<code>delete[]</code>
<strong>智能指针</strong>用来避免手动管理内存可能导致的内存泄漏</p>
<h3 id="shared_ptr">shared_ptr</h3>
<p>需要<code>#include &lt;memory&gt;</code>，属于<code>std</code>命名空间
<strong>初始化</strong>：
<code>shared_ptr&lt;int&gt; p {make_shared&lt;int&gt;(100)};</code>
<code>shared_ptr&lt;int&gt; p {new int(100)};</code>
<code>shared_ptr&lt;int&gt; p = make_shared&lt;int&gt;(100);</code>
上述几种方式完全等价
<code>p.use_count()</code>有多少个指针指向同一object
<code>p.reset()</code>重置指针，不再指向原object；也可以设置参数使其指向新的object
<strong>当指向某一object的<code>shared_ptr</code>降为0，这一object会自动销毁</strong>
<code>p.get()</code>获取指向当前object的裸指针
初始化还有一些特殊的参数配置如下：
<code>shared_ptr&lt;FILE&gt; sfp {fp, close_file};</code> 第二个参数为自定义的销毁函数
<code>shared_ptr&lt;Bar&gt; b(f, &amp;(f-&gt;b));</code> 第二个参数用于访问类的成员变量</p>
<h3 id="unique_ptr">unique_ptr</h3>
<p>库基础、初始化方式与<code>shared_ptr</code>相同
独占object的管理权，销毁时自动释放所绑定的object
<code>p.release()</code>会返回object的裸指针同时设置p为<code>nullptr</code>
控制权不可拷贝但可转移
<code>unique_ptr&lt;int&gt; p2 {p1.release()}</code>
<code>unique_ptr&lt;int&gt; p2 {move(p1)}</code>
将p1的控制权转移给p2，上述两式等价
<code>unique_ptr&lt;int, decltype(&amp;my_dealloc)&gt; cup {my_alloc(100), my_dealloc}</code> 自定义销毁函数更加复杂，需要在<code>&lt;&gt;</code>内声明
函数间传递时可以使用<code>*p</code>直接传递值，也可以使用<code>p.get()</code>传递裸指针，或者将函数的参数设置为<code>unique_ptr&lt;int&gt;&amp;</code>即<code>unique_ptr</code>的引用，还可以使用<code>move(p)</code>来改变object的控制权（此时函数的参数为<code>unique_ptr&lt;int&gt;</code>）
函数的返回值没有额外的限制，可以直接使用<code>unique_ptr&lt;int&gt;</code>类型的函数返回值初始化<code>unique_ptr&lt;int&gt;</code>，其本质也是调用<code>move</code></p>
<h3 id="weak_ptr">weak_ptr</h3>
<p>可以解决环形依赖问题
<code>weak_ptr</code>依赖<code>shared_ptr</code>存在，需要用<code>shared_ptr</code>初始化
<code>weak_ptr</code>只有object的观察权，没有object的管理权
<code>wp.lock()</code>会返回一个<code>shared_ptr</code>，若<code>weak_ptr</code>所指向的资源已释放，则返回<code>nullptr</code></p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-451807a610c5be94feb9cac83b376571">2 - C&#43;&#43; Primer</h1>
    
	<blockquote>
<p><em>C++基础知识？</em></p>
</blockquote>
<h2 id="c-primer">C++ Primer</h2>
<ul>
<li>单文件编译</li>
</ul>
<p><code>g++ -o 输出文件名 待编译文件名</code></p>
<ul>
<li>读取、输出到文件</li>
</ul>
<p><code>程序名 &lt; 输入文件</code></p>
<p><code>程序名 &gt; 输出文件</code></p>
<h3 id="数据类型">数据类型</h3>
<ul>
<li>选用的经验：</li>
</ul>
<p>数值不为负选择无符号型(unsigned)</p>
<p>整数运算选用<code>int</code>，超过表示范围的话选用<code>long long</code></p>
<p>浮点数运算选用<code>double</code></p>
<ul>
<li><strong>不要混用</strong>有符号类型和无符号类型，带符号数会自动转换为无符号数，等于初始值对无符号类型所能表示的数值总数取模后的余数</li>
<li>字符型字面值常量的类型可以通过前缀指定，整型、浮点型可以通过后缀指定</li>
</ul>
<h3 id="变量">变量</h3>
<ul>
<li>初始化和赋值存在本质上的巨大区别</li>
<li>使用列表初始化<code>{}</code>，在可能的数据丢失时会使编译器给出警告</li>
<li>声明(declaration)和定义(definition)是不同的，声明使名字为程序所知，定义则为变量申请存储空间或赋初值</li>
<li>使用<code>extern</code>关键字来<strong>声明</strong>变量</li>
<li>变量能且只能被定义一次，但可以被多次声明</li>
<li>C++是静态语言——在编译阶段检查类型</li>
<li>全局变量在块作用域内用<code>::</code>前缀可以显式访问（屏蔽块作用域内的局部变量）</li>
<li>局部变量最好不要同全局变量同名</li>
</ul>
<h3 id="复合类型">复合类型</h3>
<ul>
<li>通过在变量名前加<code>&amp;</code>来定义引用类型，引用必须初始化</li>
<li><strong>引用即别名</strong></li>
<li>引用只能绑定在对象上</li>
<li>指针存放对象的地址，使用<strong>取地址符</strong><code>&amp;</code>获取地址</li>
<li>利用指针访问对象，使用<strong>解引用符</strong><code>*</code>访问对象</li>
<li><code>&amp;</code>和<code>*</code>出现在声明和表达式中的含义<strong>截然不同</strong></li>
<li>初始化空指针(=nullptr、=0、=NULL)</li>
<li>赋值永远改变的是等号左侧的对象</li>
<li><code>void*</code>可以存放任意对象的地址</li>
<li>类型修饰符(<code>*</code>和<code>&amp;</code>)仅修饰其后的<strong>第一个</strong>变量标识符</li>
</ul>
<h3 id="const限定符">const限定符</h3>
<ul>
<li>常量引用是对const的引用</li>
<li>在初始化常量引用时允许使用<strong>任意表达式</strong>作为初始值，只要该表达式的结果能够转换成引用的类型即可</li>
<li>对const的引用可能引用一个并非const的对象</li>
<li>所谓指向常量的指针或引用不过是指针或引用**“自以为是”**地认为自己指向常量，所以自觉地不去改变所指对象的值</li>
<li>弄清声明的含义最有效的方法是从右向左阅读</li>
<li><code>*</code>放在const之前说明指针是一个常量-不变的是指针本身的值而非指向的那个值</li>
<li>指针本身是一个常量并不意味着不能通过指针修改其所指向对象的值</li>
<li>非常量可以转换为常量 反之则不行</li>
<li>常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式</li>
<li>一个对象是不是常量表达式由它的数据类型和初始值共同决定</li>
<li>顶层const 表示指针本身是个常量；底层const 表示指针所指的对象是个常量（仅示例，顶层和底层const适用于各种类型）</li>
<li>当执行对象的拷贝操作时，顶层const和底层const区别明显</li>
</ul>
<h3 id="处理类型">处理类型</h3>
<ul>
<li>类型别名：<code>typedef 前者 后者</code> —— 后者是前者的同义词</li>
<li>注意typedef中使用<code>*</code>的情况（并不是简单的替换关系），<code>const</code>是对给定类型的修饰</li>
<li>别名声明：<code>using 前者 = 后者</code> —— 前者是后者的同义词</li>
<li><code>auto</code> 根据初值自动推断数据类型（仅保留底层const）顶层const需要在auto前加以修饰</li>
<li><code>*</code>和<code>&amp;</code>只从属于某个声明符而非基本数据类型的一部分</li>
<li><code>decltype</code> 推断表达式类型而不使用其作为初值（保留变量的全部类型）</li>
<li>如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型</li>
<li>如果表达式的内容是解引用操作，则decltype将得到引用类型</li>
<li>对于decltype所用的表达式来说，在变量名上加括号与不加括号得到的类型会有不同</li>
<li><code>decltype((变量))</code>的结果永远是引用，<code>decltype(变量)</code>只有在变量本身是引用时才是引用</li>
</ul>
<h3 id="自定义数据结构">自定义数据结构</h3>
<ul>
<li><code>struct 类名 类体 ;</code></li>
<li>预处理器保证头文件多次包含仍能安全工作——头文件保护符</li>
<li><code>#define</code>把一个名字设定为预处理变量</li>
<li><code>#ifdef</code>当且仅当变量已定义时为真</li>
<li><code>#ifndef</code>当且仅当变量未定义时为真</li>
<li><code>#endif</code>检查结果为真时执行后续操作直到出现此命令</li>
<li>一般将预处理变量名全部大写以保证其唯一性</li>
<li>头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明</li>
</ul>
<h3 id="using声明">using声明</h3>
<ul>
<li><code>using namespace::name;</code></li>
<li>头文件中不应包含using声明</li>
</ul>
<h3 id="string">string</h3>
<ul>
<li><code>std::string</code> 可变长字符序列</li>
<li>在执行读取操作时，string对象会自动忽略开头的空白（空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止</li>
<li>常用操作:<code>getline(a,b)</code>——从a中读取一行（以换行符为界）赋给b <code>s.empty()</code>——判断s是否为空 <code>s.size()</code></li>
<li>size函数的返回值是一个无符号整型数（类型为<code>string::size_type</code>） 注意避免int和unsigned混用</li>
<li>string的比较：1.字符相同时，较短string小于较长string；2.字符相异时，第一对相异字符的比较</li>
<li>当string对象和字符/字符串字面值混在一条语句中时，必须确保每个+两侧的运算对象至少有一个是string</li>
<li><strong>字符串字面值与string是不同的类型</strong></li>
<li>使用C++版本的C标准库头文件 <code>ctype.h</code>=&gt;<code>cctype</code></li>
<li>cctype中包含一系列字符的判断和处理函数</li>
<li>基于范围的for语句 <code>for (declaration : expression)</code> 类似于python中的for语句</li>
<li>string中的字符可以通过下标访问</li>
<li>始终注意检查下标的合法性（是否在正确的范围内）</li>
</ul>
<h3 id="vector">vector</h3>
<ul>
<li><code>std::vector</code> 表示对象的集合（所有对象的类型相同），也被称为容器</li>
<li>vector是一个类模板而非类型</li>
<li><code>vector&lt;类型&gt; 容器名;</code></li>
<li>vector丰富的<strong>初始化</strong>方式：列表(<code>vector&lt;T&gt; v5{a,b,c...}</code>或<code>vector&lt;T&gt; v5={a,b,c...}</code>)、拷贝(<code>vector&lt;T&gt; v2(v1)</code>或<code>vector&lt;T&gt; v2 = v1</code>)、构造(<code>vector&lt;T&gt; v3(n,val)</code>或<code>vector&lt;T&gt; v3(n)</code>)&hellip;</li>
<li><code>push_back(值)</code> 将值作为vector的尾元素压到vector的尾端</li>
<li>vector能高效地快速添加元素（没有必要为其指定容量）</li>
<li>如果循环体内部包含有向vector添加元素的语句，则不能使用范围for循环</li>
<li>empty和size函数与string的类似</li>
<li>size函数的返回值也是属于vector的特殊类型<code>size_type</code> 但需要指出vector的元素类型</li>
<li>vector的比较法则也与string类似</li>
<li>vector不能使用下标添加元素，只能使用下标访问已存在的元素</li>
</ul>
<h3 id="迭代器">迭代器</h3>
<ul>
<li>有迭代器的类型同时拥有返回迭代器的成员</li>
<li><code>begin()</code>返回指向第一个元素的迭代器 <code>end()</code>返回指向尾元素下一位置**（尾后）**的迭代器</li>
<li>一般来说，我们不清楚迭代器的准确类型（使用<code>auto</code>来定义变量）</li>
<li><code>*iter</code>返回迭代器所指元素的引用 <code>iter-&gt;mem</code> <code>++iter</code>/<code>--iter</code>指示容器的下一个/上一个元素</li>
<li>泛型编程：所有标准库容器的迭代器都定义了<code>==</code>和<code>!=</code>，所以在for循环中使用<code>!=</code>而非<code>&lt;</code>，因为这种编程风格在标准库提供的所有容器中都有效</li>
<li><code>const_iterator</code>只能读元素，不能写元素</li>
<li><code>-&gt;</code>即为解引用和成员访问的结合，it-&gt;mem等价于(*it).mem</li>
<li>任何一种可能改变vector容量的操作，都会使该vector的迭代器失效</li>
<li>凡是使用了迭代器的循环体，都不要向迭代器所属的容易添加元素</li>
<li>两个迭代器相减的结果为<code>difference_type</code>（带符号整型数）</li>
</ul>
<h3 id="数组">数组</h3>
<ul>
<li>与vector类似的是存放类型相同的对象的容器；不同的是数组的大小确定不变，不能随意向其增加元素</li>
<li>数组中元素的个数也是数组类型的一部分，所以需要为常量表达式</li>
<li>数组的初始化：列表初始化，不允许拷贝</li>
<li>字符数组可以使用字符串字面值初始化，但要注意字符串字面值结尾处自带一个空字符</li>
<li>默认情况下，类型修饰符从右向左依次绑定；但对于数组而言，<strong>由（括号）内向外阅读</strong>更有意义</li>
<li>在使用数组下标时，通常将其定义为<code>size_t</code>类型</li>
<li>使用数组类型的对象其实是使用一个指向该数组首元素的指针</li>
<li>当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组；但是decltype不会发生上述转换</li>
<li>数组可以使用下标索引尾元素后那个并不存在的元素</li>
<li><code>begin(数组名)</code>/<code>end(数组名)</code>能安全地返回首元素指针/尾后元素指针</li>
<li>两个指针相减的结果为<code>ptrdiff_t</code></li>
<li>如果两个指针分别指向不相关的对象，则不能比较</li>
<li>内置的下标运算符所用的索引值不是无符号类型，这与vector和string是不同的</li>
<li><strong>C风格字符串</strong>存放在字符数组中并以空字符（<code>\0</code>）结束</li>
<li>头文件<code>cstring</code>中定义的函数可以操作C风格字符串</li>
<li>使用标准库string比使用<strong>C风格字符串</strong>更安全高效</li>
<li>尽量使用标准库类型而非数组</li>
</ul>
<h3 id="多维数组">多维数组</h3>
<ul>
<li>严格来说，C++中没有多维数组，通常所说的多维数组其实是数组的数组</li>
<li>使用<code>{}</code>括起来的一组值初始化多维数组，花括号嵌套与否完全等价（嵌套只是为了更清晰地阅读）</li>
<li>可以仅初始化部分元素，其它元素执行默认初始化</li>
<li>使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型</li>
<li>当程序使用多维数组的名字时，会自动将其转换成指向数组首元素的指针，即指向第一个内层数组的指针</li>
</ul>
<h3 id="表达式基础">表达式基础</h3>
<ul>
<li>左值和右值：左值可以位于赋值语句的左侧，右值则不能（在C++中并非如此简单）</li>
<li>当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）</li>
<li>赋值运算符需要一个非常量左值作为其左侧运算符，得到的结果也为左值</li>
<li>取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，该指针为右值</li>
<li>解引用运算符、下标运算符的求值结果为左值</li>
<li>复合表达式中，括号无视优先级与结合律</li>
<li>求值顺序在大多数运算符中没有明确规定，除了<code>&amp;&amp;</code>、<code>||</code>、<code>?:</code>、<code>,</code>外</li>
</ul>
<h3 id="运算符">运算符</h3>
<ul>
<li>整数相除的商值无论正负一律向0取整（舍弃小数部分）</li>
<li><code>(-m)/n</code>和<code>m/(-n)</code>都等价于<code>-(m/n)</code>，<code>m%(-n)</code>等价于<code>m%n</code>，<code>(-m)%n</code>等价于<code>-(m%n)</code></li>
<li>除非必须，否则不用递增递减运算符的后置版本</li>
<li><code>ptr-&gt;mem</code>等价于<code>(*ptr).mem</code> P.S.解引用运算符的优先级低于点运算符</li>
<li>条件运算符（<code>cond?expr1:expr2</code>）可嵌套 最好不超过两到三层</li>
<li>条件运算符的优先级非常低，通常需要在它两端加括号</li>
<li>仅将位运算符用于处理无符号类型</li>
<li>移位运算符（IO运算符）的优先级不高不低：低于算术运算符，高于关系运算符、赋值运算符、条件运算符</li>
<li><code>sizeof</code>返回一条表达式或一个类型名字所占的字节数 <code>sizeof (type)</code>和<code>sizeof expr</code></li>
<li><code>sizeof</code>并不实际计算其运算对象的值</li>
<li>对char或类型为char的表达式执行sizeof运算结果为1</li>
<li>sizeof运算不会把数组转换成指针来处理，等价于对数组中所有元素执行一次sizeof运算并将所得结果求和</li>
<li>对string或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间</li>
<li>逗号运算符真正的结果是右侧表达式的值</li>
</ul>
<h3 id="类型转换">类型转换</h3>
<ul>
<li>算术转换：一种算术类型-&gt;另一种算数类型，如运算符的运算对象将转换成最宽的类型，整数值将转换成浮点类型</li>
<li>整型提升：小整数类型-&gt;较大的整数类型，如<code>bool</code>、<code>char</code>、<code>short</code>提升为<code>int</code>、<code>long</code>等</li>
<li>强制类型转换<code>cast-name&lt;type&gt;(expression)</code></li>
<li>任何具有明确定义的类型转换，只要不包含底层const，都可以使用<code>static_cast</code></li>
<li>当需要把一个较大的算术类型赋值给较小的类型时，<code>static_cast</code>非常有用</li>
<li><code>static_cast</code>对于编译器无法自动执行的类型转换也非常有用</li>
<li><code>const_cast</code>只能改变运算对象的底层const，只有<code>const_cast</code>能改变表达式的常量属性</li>
<li>使用<code>reinterpret_cast</code>非常危险</li>
<li>要尽量避免强制类型转换</li>
<li>旧式的强制类型转换 <code>type (expr)</code>和<code>(type) expr</code>，不够清晰明了，追踪困难</li>
</ul>
<h3 id="运算符优先级">运算符优先级</h3>
<h3 id="条件语句">条件语句</h3>
<ul>
<li><code>else</code>与离它最近的未匹配的<code>if</code>匹配，使用花括号可以强制匹配</li>
<li><code>case</code>标签必须是整形常量表达式</li>
<li>如果在某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为为非法行为</li>
</ul>
<h3 id="迭代语句">迭代语句</h3>
<ul>
<li>传统for循环的执行流程：首先执行init-statement；接下来判断condition；条件为真，执行循环体；最后执行expression</li>
<li>for语句中的init-statement可定义多个对象，但只能有一条声明语句，所以所有变量的基础类型<strong>必须相同</strong></li>
<li>在范围for语句中，当范围变量为引用类型时，才能对元素执行写操作</li>
<li>在范围for语句中，使用<code>auto</code>可以保证类型相容</li>
<li>范围for语句的等价传统for语句（不能用范围for语句增加vector对象或其他容器的元素）</li>
<li><code>do while</code>与<code>while</code>十分相似，只是先执行循环体后检查条件</li>
</ul>
<h3 id="跳转语句">跳转语句</h3>
<ul>
<li><code>break</code>负责终止离它最近的<code>while</code>、<code>do while</code>、<code>for</code>、<code>switch</code>语句，并从这些语句后的第一条语句开始继续执行</li>
<li><code>continue</code>用于终止离它最近的<code>for</code>、<code>while</code>、<code>do while</code>循环中的当前迭代并立即开始下一次迭代</li>
<li><code>goto label;</code> label是用于标识一条语句的标示符</li>
</ul>
<h3 id="try语句块和异常处理">try语句块和异常处理</h3>
<ul>
<li>程序的异常检测部分使用<code>throw</code>表达式引发一个异常</li>
<li><code>try</code>块后跟随一个或多个<code>catch</code>子句，由<code>try</code>中抛出的异常来选中对应的<code>catch</code>子句</li>
<li>C风格字符串（<code>const char*</code>）</li>
<li>异常中断了程序的正常流程，那些在异常发生期间正确执行了“清理”工作的程序被称作<strong>异常安全</strong>的代码</li>
<li><code>stdexcept</code>头文件定义了几种常用的异常类，另外几种异常类型：<code>exception</code>、<code>bad_alloc</code>、<code>bad_cast</code></li>
<li>后三种异常只能以默认初始化的方式初始化，不允许为这些对象提供初始值；其它异常类型使用string对象或者C风格字符串初始化这些类型的对象，不允许使用默认初始化的方式</li>
<li>异常类型只定义了一个成员函数<code>what</code>，该函数没有参数，返回一个指向C风格字符串的<code>const char*</code>，提供关于异常的信息</li>
</ul>
<h3 id="函数基础">函数基础</h3>
<ul>
<li>函数形参列表中的形参通常用逗号隔开，其中每个形参都含有一个声明符的声明，即使两个形参的类型一样，也<strong>必须</strong>把两个类型都写出来</li>
<li>形参名是<strong>可选</strong>的，当函数确实有个别形参不会被用到时，此类形参通常不命名以表示在函数体内不会使用它</li>
<li>函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针</li>
<li>名字有作用域，对象有生命周期</li>
<li>形参和函数体内部定义的变量为<strong>局部变量</strong>，仅在函数的作用域内可见，还会隐藏在外层作用域中同名的其他所有声明中</li>
<li>只存在于块执行期间的对象成为<strong>自动对象</strong></li>
<li><strong>局部静态对象</strong>在程序的执行路径第一次经过对象定义语句时初始化，并直到程序终止才被销毁——<code>static</code></li>
<li>函数名需要在使用前声明，函数只能定义一次，但可以声明多次，函数声明无需函数体，用<code>;</code>替代即可</li>
<li>函数声明也称作<strong>函数原型</strong></li>
<li>含有函数声明的头文件应该被包含到定义函数的源文件中</li>
<li><strong>分离式编译</strong>允许程序分散在几个文件中，每个文件独立编译</li>
</ul>
<h3 id="参数传递">参数传递</h3>
<ul>
<li>引用传递和值传递</li>
<li>C++中建议使用引用类型的形参代替指针类型访问函数外部的对象</li>
<li>使用引用来避免拷贝</li>
<li>当函数无须修改引用形参的值时最好使用常量引用</li>
<li>使用引用形参返回额外信息：一个函数只能返回一个值，但有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效途径</li>
<li>用实参初始化形参时会忽略掉顶层const（作用于对象本身）</li>
<li>在C++中允许定义若干具有相同名字的函数，前提是不同函数的形参列表有<strong>明显</strong>的区别</li>
<li>可以用非常量初始化一个底层const对象，但反之不行；一个普通的引用必须用同类型的对象初始化</li>
<li>C++允许使用字面值初始化常量引用</li>
<li>尽量使用常量引用，把函数不会改变的形参定义为普通引用是一种常见错误</li>
<li>数组的特殊性：不允许拷贝数组，使用数组时会将其转换成指针</li>
<li>尽管不能以值传递的方式传递数组，但可以把形参写成类似数组的形式，本质上传递的还是指向数组首元素的指针</li>
<li>管理指针形参（数组实参）的三种技术：1.使用标记指定数组长度；2.使用标准库规范（传递指向数组首元素和尾后元素的指针）；3.显式传递一个表示数组大小的形参</li>
<li>形参也可以是数组的引用，如<code>int (&amp;arr)[10]</code>，数组大小是构成数组类型的一部分</li>
<li>传递多维数组，如<code>int matrix[][10]</code>，编译器会忽略第一个维度，最好不要把它包括在形参列表内。matrix的声明看起来是一个二维数组，实际上形参是指向含有10个整数的数组的指针</li>
<li><code>int main(int argc, char *argv[]) {...}</code> 第二个形参是一个数组，其元素是指向C风格字符串的指针；第一个形参表示数组中字符串的数量</li>
<li><code>int main(int argc, char **argv) {...}</code>等价于上述代码</li>
<li>当使用argv中的实参时，可选的实参从<code>argv[1]</code>开始，<code>argv[0]</code>保存程序名</li>
<li>如果函数的实参数量未知但全部实参的类型<strong>都相同</strong>，可以使用<code>initializer_list</code>类型的形参，使用方式类似于<code>vector</code></li>
<li><code>initializer_list</code>中的元素永远是常量值，无法改变<code>initializer_list</code>对象中元素的值</li>
<li>省略符形参是为了便于C++程序访问某些特殊的C代码（使用了C标准库varargs）而设置的，形如<code>void foo(parm_list, ...);</code>和<code>void foo(n...)</code></li>
</ul>
<h3 id="返回类型和return语句">返回类型和return语句</h3>
<ul>
<li>返回void的函数不必须要有return，因为在最后总会隐式执行。若想让函数提前退出，可以使用return。</li>
<li>在含有return语句的循环后也应该有一条return语句，否则程序是错误的且难以被编译器发现</li>
<li>不要返回局部对象的引用或指针</li>
<li>引用返回左值：调用一个返回引用的函数得到左值，其他返回类型得到右值</li>
<li>C++11规定，函数可以返回<code>{}</code>包围的值的列表(返回类型为<code>vector&lt;类型&gt;</code>)</li>
<li>头文件<code>cstdlib</code>中定义了两个预处理变量<code>EXIT_FAILURE</code>、<code>EXIT_SUCCESS</code>，可以作为main函数的返回值</li>
<li>递归：函数调用自身（main函数不能调用自己）</li>
<li>函数不能返回数组但可以返回数组的指针或引用</li>
<li>要想定义一个返回数组的指针或引用可以<strong>使用类型别名</strong>，如<code>typedef int arrT[10]</code>、等价写法<code>using arrT = int[10] </code>，此时，<code>arrT* func(int i)</code>中的func函数即返回一个指向含有10个整数的数组的指针</li>
<li>除了类型别名，返回数组指针的函数形式如<code>Type (*function(parameter_list))[dimension]</code></li>
<li>还可以使用<strong>尾置返回类型</strong>，如<code>auto func(int i) -&gt; int(*)[10]</code></li>
<li>或者使用<code>decltype(数组名)*</code>来声明函数</li>
</ul>
<h3 id="函数重载">函数重载</h3>
<ul>
<li>重载函数：同一作用域内的几个函数名相同但形参列表不同（main函数不能重载）</li>
<li>重载函数的返回类型需要一致，不允许同名函数返回不同的类型</li>
<li>顶层const形参并不区分重载函数而底层const（指针、引用）可以区分重载函数</li>
<li>最好只重载非常相似的操作</li>
<li><code>const_cast</code>在重载函数的情景中最有用</li>
<li><strong>函数匹配</strong>也叫<strong>重载确定</strong>，在调用重载函数时可能的三种结果：最佳匹配、无匹配、二义性调用</li>
<li>在C++中，<strong>名字查找</strong>发生在<strong>类型检查</strong>之前</li>
</ul>
<h3 id="特殊用途语言特性">特殊用途语言特性</h3>
<ul>
<li>一旦某个形参被赋予了默认值，它后面的所有形参<strong>都必须有</strong>默认值</li>
<li>默认实参负责填补函数调用缺少的<strong>尾部实参</strong></li>
<li>当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，让那些经常使用默认值的形参出现在后面</li>
<li>在给定的作用域中一个形参<strong>只能被赋予一次</strong>默认实参，函数的后续声明只能为之前没有默认值的形参添加默认实参，且该形参右侧的所有形参必须都有默认值</li>
<li>应在函数声明中指定默认实参，并将该声明放在合适的头文件中</li>
<li>只要表达式的类型<strong>能转换成</strong>形参所需的类型，该表达式就能作为默认实参；用作默认实参的名字在<strong>函数声明所在的作用域内</strong>解析，而这些名字的<strong>求值过程</strong>发生在<strong>函数调用</strong>时</li>
<li>内联函数可以避免函数调用的开销</li>
<li>在函数返回类型前加上<code>inline</code>就可将其声明为内联函数</li>
<li>内联说明只是向编译器发出请求，编译器可以选择忽略这个请求</li>
<li>内联机制一般用于优化规模较小、流程直接、频繁调用的函数</li>
<li>constexpr函数是指能用于<strong>常量表达式</strong>的函数，函数的返回类型及所有形参的类型<strong>都为字面值类型</strong>且函数体中有且只有一条retuen语句</li>
<li>在编译过程中，constexpr函数被隐式指定为内联函数</li>
<li>允许constexpr函数的返回值<strong>并非一个常量</strong></li>
<li>内联函数和constexpr函数通常放在头文件中</li>
<li><code>assert</code>预处理宏，用法：<code>assert (expr)</code>，对expr求值，若为假，输出信息并终止运行；若为真，什么也不做</li>
<li>预处理名字由预处理管理器而非编译器管理，应直接使用预处理名字而<strong>无需using声明</strong></li>
<li><code>assert</code>的行为依赖于<code>NDEBUG</code>预处理变量的状态，当<code>#define NDEBUG</code>时，<code>assert</code>什么也不做</li>
<li>编译器定义了一些局部静态变量用于程序调试，<code>_ _func_ _</code>、<code>_ _FILE_ _</code>、<code>_ _LINE_ _</code>、<code>_ _TIME_ _</code>、<code>_ _DATE_ _</code></li>
</ul>
<h3 id="函数匹配">函数匹配</h3>
<ul>
<li>候选函数：同名函数、声明可见</li>
<li>可行函数：形参数量相等、形参类型相同</li>
<li>寻找最佳匹配</li>
<li>如果没有一个函数脱颖而出，编译器会因调用具有二义性而拒绝请求</li>
<li>调用重载函数应尽量避免强制类型转换。如果在实际应用中确需强制类型转换，则说明设计的形参集合不合理。</li>
<li>实参类型转换的等级：1.精确匹配；2.通过const转换实现的匹配；3.通过类型提升实现的匹配；4.通过算数类型转换或指针转换实现的匹配；5.通过类类型转换实现的匹配</li>
<li>内置类型提升和转换可能在函数匹配时产生意想不到的结果</li>
<li>所有算数类型转换的级别都一样</li>
</ul>
<h3 id="函数指针">函数指针</h3>
<ul>
<li>函数指针指向的是函数而非对象</li>
<li>函数<code>bool lengthCompare(const string &amp;, const string &amp;);</code>，声明一个指向该函数的指针，<code>bool (*pf)(const string &amp;, const string &amp;);</code></li>
<li><code>pf = lengthCompare;</code>等价于<code>pf = &amp;lengthCompare</code></li>
<li><code>bool b = pf(&quot;hello&quot;,&quot;goodbye&quot;);</code>等价于<code>bool b = (*pf)(&quot;hello&quot;,&quot;goodbye&quot;);</code>等价于<code>bool b = lengthCompare(&quot;hello&quot;,&quot;goodbye&quot;);</code></li>
<li>与数组类似，虽然不能定义函数类型的形参，但形参可以是指向函数的指针，形参看起来是函数类型，实际上当作指针；可以直接把函数作为实参使用，它也会自动转换为指针</li>
<li>使用类型别名和<code>decltype</code>可以简化使用函数指针的代码，如<code>typedef decltype(lengthCompare) Func;</code>定义了函数类型，<code>typedef decltype(lengthCompare) *FuncP;</code>定义了函数指针</li>
<li><code>using F = int(int*, int);</code>定义了函数类型F，<code>using PF = int(*)(int*, int);</code>定义了指向函数类型的指针PF</li>
<li>当<code>decltype</code>作用于函数时，它返回函数类型而非指针类型，需要显式地加上<code>*</code>来表示需要返回指针</li>
</ul>
<h3 id="定义抽象数据类型">定义抽象数据类型</h3>
<ul>
<li>类=数据抽象+封装；数据抽象=接口+实现</li>
<li>定义在类内部的函数是隐式的<code>inline</code>函数</li>
<li><strong>成员函数</strong>的声明必须在类的内部，它的定义既可以在类的内部也可以在类的外部；作为接口组成部分的<strong>非成员函数</strong>，它们的定义和声明都在类的外部</li>
<li>成员函数通过一个名为<code>this</code>的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化<code>this</code></li>
<li>因为<code>this</code>的目的总是指向“这个”对象，所以<code>this</code>是一个<strong>常量指针</strong>，不允许改变<code>this</code>中保存的地址</li>
<li>当把<code>const</code>关键字放在成员函数的参数列表之后，紧跟在参数列表后的<code>const</code>的作用是修改隐式<code>this</code>指针的类型，表示<code>this</code>是一个<strong>指向常量的指针</strong>=&gt;这样使用<code>const</code>的成员函数称为<strong>常量成员函数</strong></li>
<li>常量成员函数不能改变调用它的对象的内容</li>
<li>常量对象，以及常量对象的引用或指针都只能调用常量成员函数</li>
<li>编译器首先编译成员的声明，然后才轮到成员函数体。所以，成员函数体可以<strong>随意</strong>使用类中的其它成员而无需在意这些成员出现的次序</li>
<li>成员函数的定义必须与它的声明匹配，同时，类外部定义的成员的名字必须包含它所属的类名</li>
<li><code>return *this</code>返回调用该函数的对象，函数的返回类型应为对应类型的引用</li>
<li>如果非成员函数是类接口的组成部分，这些函数的声明应该与类在同一个头文件内</li>
<li>构造函数<strong>不能</strong>被声明成<code>const</code>的</li>
<li>编译器创建的构造函数又称<strong>合成的默认构造函数</strong></li>
<li><strong>只有</strong>当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数</li>
<li>如果类包含有内置类型或者符合类型的成员，则只有当这些成员<strong>全都</strong>被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数</li>
<li><code>= default</code>要求编译器生成默认构造函数</li>
<li>构造函数初始值列表在<code>函数名(参数列表):</code>后，在<code>{}</code>函数体之前</li>
<li>构造函数初始值列表是成员名的一个列表，每个名字后紧跟<code>()</code>括起来的成员初始值，不同成员的初始化通过逗号分隔</li>
<li>当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化</li>
<li>一般来说，编译器生成的拷贝、赋值和析构操作将对<strong>对象的每个成员</strong>执行拷贝、赋值和销毁操作</li>
<li>很多需要动态内存的类应该使用<code>vector</code>对象或<code>string</code>对象管理必要的存储空间，使用<code>vector</code>或<code>string</code>能避免分配和释放内存带来的复杂性</li>
<li>如果类包含<code>vector</code>或<code>string</code>成员，则其<strong>拷贝、赋值和销毁</strong>的合成版本能正常工作</li>
</ul>
<h3 id="访问控制与封装">访问控制与封装</h3>
<ul>
<li>使用<strong>访问说明符</strong>（<code>public</code>、<code>private</code>）加强类的封装性</li>
<li><code>class</code>和<code>struct</code>关键字唯一的区别在于其默认访问权限不太一样，可以用任意一个来定义类</li>
<li><code>struct</code>：第一个访问说明符前的成员是<code>public</code>的；<code>class</code>：第一个访问说明符前的成员是<code>private</code>的</li>
<li>类可以允许其它类或函数访问其非公有成员-&gt;<strong>友元</strong></li>
<li>友元声明只需要在类内增加一条以<code>friend</code>关键字开始的函数声明语句即可</li>
<li>友元声明<strong>适用于</strong>类的接口组成部分非成员函数</li>
<li>友元声明<strong>仅仅指定访问权限</strong>，而非通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，<strong>必须</strong>在友元声明外再专门声明一次函数。</li>
<li>通常在类的头文件中，除了类内部的友元声明外独立声明友元函数（在类外）</li>
<li>最好在类定义开始或结束前的位置集中声明友元</li>
</ul>
<h3 id="类的其它特性">类的其它特性</h3>
<ul>
<li>用来定义类型的成员必须<strong>先定义后使用</strong>，因此，类型成员通常出现在类开始的地方</li>
<li>最好只在类外部定义的地方说明<code>inline</code>，可以使类更易理解</li>
<li>只要函数在参数的数量和/或类型上有所区别，就可以重载成员函数</li>
<li>当我们希望能修改类的某个数据成员，即使是在一个<code>const</code>成员函数内，可以通过在变量声明中加上<code>mutable</code>实现</li>
<li>当我们提供一个类内初始值时，<strong>必须</strong>以<code>=</code>或<code>{}</code>表示</li>
<li>一个<code>const</code>成员函数如果以引用的形式返回<code>*this</code>，那么它的返回类型将是常量引用</li>
<li>通过区分成员函数是否是<code>const</code>的，可以对其进行<strong>重载</strong></li>
<li>建议：对于公共代码使用私有功能函数-&gt;避免在多处使用同样的代码</li>
<li>我们可以仅仅声明类而暂时不定义它（类似于函数），如<code>class Screen;</code>-&gt;<strong>前向声明</strong></li>
<li>在 &ldquo;声明之后&rdquo; &ldquo;定义之前&rdquo; 的类类型是一个不完全类型</li>
<li>前向声明<strong>适用于</strong>当类的成员包含指向它自身类型的引用或指针</li>
<li>如果一个类指定了友元类<code>friend class 类名</code>，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员</li>
<li>每个类负责控制自己的友元类或友元函数,友元关系不存在传递性</li>
<li>当把一个成员函数声明成友元时，必须明确指出该成员函数属于哪个类，如<code>类名::成员函数名</code></li>
<li>要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系</li>
<li>如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个<strong>分别</strong>声明</li>
</ul>
<h3 id="类的作用域">类的作用域</h3>
<ul>
<li>一个类就是一个作用域的事实很好地解释为什么当我们在类的外部定义成员函数时必须同时提供类名和函数名</li>
<li><strong>一旦遇到类名</strong>，定义的剩余部分就在类的作用域之内了</li>
<li>返回类型必须指明它是哪个类的成员(返回类型中使用的名字都位于类的作用域之外)</li>
<li>编译器处理完类中的全部声明后才会处理成员函数的定义</li>
<li>在类中，如果成员使用了外层作用域中的某个名字，而<em>该名字代表一种类型</em>，则类<strong>不能</strong>在之后重新定义该名字</li>
<li>当类的成员被隐藏时，可以通过加上类的名字或显式地使用<code>this</code>指针来强制访问成员，如<code>this-&gt;成员变量名</code>或<code>类名::成员变量名</code></li>
<li>建议不要把成员名作为参数或其它局部变量使用</li>
<li>当外部作用域的对象被隐藏时，可以使用作用域运算符访问它</li>
</ul>
<h3 id="构造函数再探">构造函数再探</h3>
<ul>
<li>初始化和先定义后赋值在一些情况下有很大不同</li>
<li>如果成员是<code>const</code>或引用或属于某种类类型而该类没有定义默认构造函数时，<strong>必须将其初始化</strong></li>
<li>应养成<strong>使用构造函数初始值</strong>的习惯</li>
<li>成员的初始化顺序与它们在类定义中出现的顺序<strong>一致</strong>，最好令构造函数初始值的顺序与成员声明的顺序<strong>一致</strong>，如果可能的话<strong>尽量避免</strong>使用某些成员初始化其他成员</li>
<li>如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数</li>
<li><strong>委托构造函数</strong>使用它所属类的其它构造函数执行其自身的初始化过程，其成员初始值列表只有唯一的入口，即类名，如<code>Sales_data(): Sales_data(&quot;&quot;, 0, 0){函数体}</code></li>
<li>当对象被<strong>默认初始化</strong>或<strong>值初始化</strong>时自动执行默认构造函数，类必须包含一个默认构造函数以便在这些情况下使用</li>
<li>如果定义了其他构造函数，最好也提供一个默认构造函数</li>
<li>编译器只会自动地执行一步类类型转换</li>
<li><code>explicit</code>可以用来抑制构造函数的隐式转换，只能在类内声明构造函数时使用，<code>explicit</code>只对一个实参的构造函数有效，需要多个实参的构造函数不能用于隐式转换，无须为其指定</li>
<li>当使用<code>explicit</code>关键字声明构造函数时，它将<strong>只能</strong>以直接初始化的形式使用，且编译器不会在自动转换过程中使用该构造函数</li>
<li>尽管编译器不会将<code>explicit</code>构造函数用于隐式转换，但我们可以用这样的构造函数显式地强制转换，如<code>static_cast</code></li>
<li>聚合类：1.所有成员<code>public</code> 2.未定义任何构造函数 3.无类内初始值 4.无基类，也无<code>virtual</code>函数</li>
<li>聚合类可以使用由花括号括起来的成员初始值列表初始化，如<code>Data val1 = { 0, &quot;Anna&quot;}</code>，初始值的顺序必须与声明的顺序一致，若初始值列表的元素个数少于类的成员数，则靠后的成员被值初始化</li>
<li>数据成员都是字面值类型的聚合类是字面值常量类</li>
<li>如果
<ul>
<li>数据成员都是字面值类型；</li>
<li>类至少含有一个<code>constexpr</code>构造函数；</li>
<li>如果一个数据成员含有类内初始值，则内置类型成员的初始值是一条常量表达式，或者如果成员属于某种类类型，则初始值使用成员自己的<code>constexpr</code>构造函数；</li>
<li>类必须使用析构函数的默认定义
则它也是一个字面值常量类</li>
</ul>
</li>
<li><code>constexpr</code>构造函数体一般是空的，使用前置关键字就可以声明一个<code>constexpr</code>构造函数</li>
</ul>
<h3 id="类的静态成员">类的静态成员</h3>
<ul>
<li>使用<code>static</code>关键字使得成员与类本身直接相关，而不是与类的各个对象保持关联</li>
<li>类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据</li>
<li>静态成员函数不与任何对象绑定在一起，不包含<code>this</code>指针，无法声明为<code>const</code></li>
<li>可以使用作用域运算符直接访问静态成员，也可以使用类的对象、引用或指针来访问静态成员，成员函数不用通过作用域运算符就能直接使用静态成员</li>
<li>既可以在类内也可以在类外定义静态成员函数，在类外定义时<strong>不能重复</strong><code>static</code>关键字</li>
<li>必须在类的外部定义和初始化每个静态成员</li>
<li>从类名开始，一条定义语句的剩余部分就都位于类的作用域之内了</li>
<li>静态数据成员的类型可以是它所属的类类型，而非静态数据成员只能声明为它所属类的指针或引用</li>
<li>静态成员和普通成员的另一个重要区别是我们可以使用静态成员作为默认实参，但非静态成员不行，因为它的值本身属于对象的一部分</li>
</ul>
<h3 id="io类">IO类</h3>
<ul>
<li><code>iostream</code>、<code>fstream</code>、<code>sstream</code>三个头文件分别定义了用于读写<strong>流</strong>、<strong>命名文件</strong>、<strong>内存string对象</strong>的类型</li>
<li>标准库通过<strong>继承机制</strong>使我们能忽略这些不同类型的流之间的差异</li>
<li><strong>不能</strong>拷贝或对IO对象赋值</li>
<li>IO类的条件状态，确定一个流对象的状态最简单的方法是将其作为一个条件使用，如<code>while</code>循环检查<code>&gt;&gt;</code>表达式返回的流的状态</li>
<li>流对象的<code>rdstate</code>成员返回一个<code>iostate</code>值，对应流的当前状态</li>
<li>流对象的<code>clear</code>成员可以复位所有错误标志位（无参数）或设置流的新状态（有参数）</li>
<li>缓冲刷新：数据真正写到输出设备或文件，导致缓冲刷新的原因有很多</li>
<li><code>endl</code>完成换行并刷新缓冲区工作；<code>flush</code>刷新缓冲区但不输出任何额外字符；<code>ends</code>向缓冲区插入一个空字符并刷新缓冲区</li>
<li>如果程序崩溃，输出缓冲区不会被刷新</li>
<li><code>cout&lt;&lt;unitbuf;</code>告诉流在每次写操作后进行一次<code>flush</code>；<code>cout&lt;&lt;nounitbuf;</code>恢复为正常的缓冲区刷新机制</li>
<li>当一个输入流关联到一个输出流时，从输入流读取数据的操作<strong>会先刷新</strong>关联的输出流，<code>cout</code>和<code>cin</code>就是关联在一起的</li>
<li><code>x.tie(&amp;o)</code>将流x关联到输出流o</li>
<li>既可以将<code>istream</code>关联到<code>ostream</code>，也可将<code>ostream</code>关联到<code>ostream</code></li>
<li>每个流同时最多关联到一个流，但多个流可以同时关联到同一个<code>ostream</code></li>
</ul>
<h3 id="文件输入输出">文件输入输出</h3>
<ul>
<li>头文件<code>fstream</code>定义了三个类型来支持文件IO:<code>ifstream</code>-读；<code>ofstream</code>-写；<code>fstream</code>-读写</li>
<li><code>fstream</code>的各类特有操作</li>
<li><code>ifstream in(ifile);</code>构造一个<code>ifstream</code>并打开给定文件</li>
<li>调用<code>open</code>可以将空文件流与文件相关联，例如<code>ofstream out;</code>、<code>out.open(ofile);</code>。使用<code>if (out)</code>可以判断<code>open</code>是否成功。</li>
<li>为了将文件流关联到另一文件，必须先关闭已关联文件，例如<code>in.close()</code>、<code>in.open(ifile)</code>。</li>
<li>当一个<code>fstream</code>对象被销毁时，<code>close</code>会自动被调用。</li>
<li>文件模式：<code>in</code>-读方式；<code>out</code>-写方式；<code>app</code>-每次写操作前定位到文件末尾；<code>ate</code>-打开文件后定位到文件末尾；<code>trunc</code>-截断文件；<code>binary</code>-以二进制方式进行IO</li>
<li>以<code>out</code>模式（<code>ofstream</code>的默认模式）打开文件会丢弃已有数据</li>
<li>阻止一个<code>ofstream</code>清空给定文件内容的方法是同时指定<code>app</code>模式，例如<code>ofstream app(&quot;file&quot;, ofstream::out| ofstream::app);</code></li>
<li>每次打开文件时，都要设置文件模式，否则使用默认值</li>
</ul>
<h3 id="string流">string流</h3>
<ul>
<li><code>istringstream</code>-读；<code>ostringstream</code>-写;<code>stringstream</code>-读写</li>
<li><code>stringstream</code>的各类特有操作</li>
<li><code>istringstrean</code>和<code>ostringstream</code>的使用</li>
<li>string流在拆分从文件中读入的字符串时<strong>非常有用</strong></li>
</ul>
<h3 id="顺序容器概述">顺序容器概述</h3>
<ul>
<li><code>vector</code>-可变大小数组；<code>deque</code>-双端队列；<code>list</code>-双向链表；<code>forward_list</code>-单向链表；<code>array</code>-固定大小数组；<code>string</code>-与<code>vector</code>相似的容器，但专门用于保存字符</li>
<li><code>string</code>和<code>vector</code>将元素保存在连续的内存空间中：由元素下标计算地址非常快速，但在中间位置添删元素非常耗时</li>
<li><code>list</code>和<code>forward_list</code>令容器任何位置的添删操作都很快速，但不支持元素的随机访问，额外内存开销很大</li>
<li><code>deque</code>更为复杂，支持快速的随机访问，在中间位置添删元素代价很高，但在两端添删元素速度很快</li>
<li><code>array</code>大小固定，不支持添删元素和改变容器大小</li>
<li>现代C++程序应该使用标准库容器，而不是原始的数据结构，如内置数组</li>
<li>除非有很好的理由选择其他容器，<strong>否则使用</strong><code>vector</code></li>
<li>如果程序有很多小元素，且空间额外开销很重要，<strong>不要使用</strong><code>list</code>或<code>forward_list</code></li>
<li>如果程序要求随机访问元素，应使用<code>vector</code>或<code>deque</code></li>
<li>如果程序要求在容器中间添删元素，应使用<code>list</code>或<code>forward_list</code></li>
<li>如果程序需要在头尾添删元素，但不需要在中间添删元素，使用<code>deque</code></li>
<li>如果程序只有在读取输入时才需要在容器中间插入元素，随后需要随机访问元素：首先确定是否真的需要在容器中间插入元素，在处理输入数据时，可以很容易地向<code>vector</code>追加数据，再调用标准库的<code>sort</code>函数来重排容器内元素，从而避免在中间插入元素；如果必须在中间位置插入元素，考虑在输入阶段使用<code>list</code>，一旦输入完成，将<code>list</code>中内容拷贝到<code>vector</code>中。</li>
<li>不确定使用何种容器，可以在程序中只使用<code>vector</code>和<code>list</code>的公共操作：使用迭代器，不使用下标操作，避免随机访问。这样在必要时选择使用<code>vector</code>或<code>list</code>都很方便</li>
</ul>
<h3 id="容器库概览">容器库概览</h3>
<ul>
<li>
<p>每个容器都定义在一个头文件中，文件名与类型名相同。容器均定义为模板类，大部分容器都需要额外提供元素类型信息。</p>
</li>
<li>
<p>顺序容器几乎可以保存任意类型的元素</p>
</li>
<li>
<p>容器操作：类型别名、构造函数、赋值与swap、大小、增删元素、获取迭代器、反向容器的额外成员</p>
</li>
<li>
<p>迭代器范围由一对迭代器表示，<code>[begin,end)</code>左闭右开区间，需要保证end不在begin之前，且指向同一个容器的元素或尾后元素</p>
</li>
<li>
<p>借助<strong>类型别名</strong>，可以在不了解容器中元素类型的情况下使用它，这在<strong>泛型编程</strong>中非常有用</p>
</li>
<li>
<p><code>begin</code>和<code>end</code>操作生成指向容器中首元素和尾后元素的迭代器，形成一个包含容器中所有元素的迭代器范围</p>
</li>
<li>
<p><code>begin</code>和<code>end</code>有多个版本:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#000">list</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">string</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">a</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">{</span><span style="color:#4e9a06">&#34;Milton&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#4e9a06">&#34;Shakespeare&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#4e9a06">&#34;Austen&#34;</span><span style="color:#000;font-weight:bold">};</span>
<span style="color:#204a87;font-weight:bold">auto</span> <span style="color:#000">it1</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">a</span><span style="color:#000;font-weight:bold">.</span><span style="color:#000">begin</span><span style="color:#000;font-weight:bold">();</span> <span style="color:#8f5902;font-style:italic">// list&lt;string&gt;::iterator
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#204a87;font-weight:bold">auto</span> <span style="color:#000">it2</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">a</span><span style="color:#000;font-weight:bold">.</span><span style="color:#000">rbegin</span><span style="color:#000;font-weight:bold">();</span> <span style="color:#8f5902;font-style:italic">// list&lt;string&gt;::reverse_iterator
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#204a87;font-weight:bold">auto</span> <span style="color:#000">it3</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">a</span><span style="color:#000;font-weight:bold">.</span><span style="color:#000">cbegin</span><span style="color:#000;font-weight:bold">();</span> <span style="color:#8f5902;font-style:italic">// list&lt;string&gt;::const_iterator
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#204a87;font-weight:bold">auto</span> <span style="color:#000">it4</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">a</span><span style="color:#000;font-weight:bold">.</span><span style="color:#000">crbegin</span><span style="color:#000;font-weight:bold">();</span> <span style="color:#8f5902;font-style:italic">// list&lt;string&gt;::const_reverse_iterator
</span></code></pre></div></li>
<li>
<p>当不需要写访问时，应使用<code>cbegin</code>和<code>cend</code></p>
</li>
<li>
<p>容器的定义和初始化：默认构造函数，拷贝初始化<code>c1(c2)</code>或<code>c1=c2</code>，列表初始化<code>c{a,b,c...}</code>或<code>c={a,b,c...}</code>。只有顺序容器的构造函数才能接受大小参数<code>seq(n,t)</code>，关联容器并不支持</p>
</li>
<li>
<p>拷贝初始化：1.拷贝整个容器；2.拷贝由一个迭代器对所指定的元素范围</p>
</li>
<li>
<p>当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同</p>
</li>
<li>
<p>顺序容器提供的构造函数可以接受一个容器大小和一个元素初始值，例如<code>vector&lt;int&gt; ivec(10,-1);</code></p>
</li>
<li>
<p>定义一个<code>array</code>时，除了指定元素类型，还必须指定大小，例如<code>array&lt;int, 42&gt;</code></p>
</li>
<li>
<p>虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但<code>array</code>并无此限制</p>
</li>
<li>
<p>容器的赋值运算可用于所有容器</p>
</li>
<li>
<p>赋值运算将左边容器的全部元素替换为右边容器元素的拷贝</p>
</li>
<li>
<p><code>swap</code>(交换元素)通常比直接拷贝快得多,如<code>swap(c1,c2)</code>、<code>c1.swap(c2)</code></p>
</li>
<li>
<p><code>assign</code>(替换元素)仅适用于顺序容器，不支持关联容器和<code>array</code>，如<code>seq.assign(b,e)</code>、<code>seq.assign(il)</code>、<code>seq.assign(n,t)</code></p>
</li>
<li>
<p>赋值相关运算会导致容器内部的迭代器、引用和指针失效，但<code>swap</code>不会</p>
</li>
<li>
<p>除<code>array</code>外，<code>swap</code>不对任何元素进行拷贝删除或插入，可以保证在常数时间完成</p>
</li>
<li>
<p>除<code>string</code>外，指向容器的迭代器、引用和指针在<code>swap</code>操作后仍指向<code>swap</code>操作前所指向的元素</p>
</li>
<li>
<p>交换两个<code>array</code>所需时间与<code>array</code>中的元素数目成正比</p>
</li>
<li>
<p>统一使用非成员版本的<code>swap</code>是一个好习惯</p>
</li>
<li>
<p>容器大小操作:<code>size</code>、<code>empty</code>、<code>max_size</code></p>
</li>
<li>
<p>比较两个容器实际上进行元素的逐对比较，与<code>string</code>的关系运算类似：大小相同元素相等则相等；大小不同元素相等则小容器小于大容器；大小不同元素不等则取决于第一个不等元素的比较结果</p>
</li>
</ul>
<h3 id="顺序容器操作">顺序容器操作</h3>
<ul>
<li>添加元素：<code>push_back(t)</code>或<code>emplace_back(args)</code>、<code>push_front(t)</code>或<code>emplace_front(args)</code>、<code>insert(p,t)</code>或<code>emplace(p,args)</code>及多种<code>insert</code>操作</li>
<li>向一个<code>vector</code>、<code>string</code>、<code>deque</code>插入元素会使所有指向容器的迭代器、引用和指针失效</li>
<li>除<code>array</code>和<code>forward_list</code>外，每个顺序容器都支持<code>push_back</code></li>
<li>当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器的是对象值的一个拷贝，而不是对象本身。</li>
<li><code>list</code>、<code>forward_list</code>、<code>deque</code>还支持<code>push_front</code>，<code>deque</code>像<code>vector</code>一样提供随机访问元素的能力，但它提供了<code>vector</code>所不支持的<code>push_front</code>，<code>deque</code>保证在容器收尾插入和删除元素的操作都只花费常数时间，与<code>vector</code>一样，在<code>deque</code>首尾之外的位置插入元素会很耗时</li>
<li>将元素<strong>插入</strong>到<code>vector</code>、<code>deque</code>、<code>string</code>中的任何位置都是合法的，但可能很耗时</li>
<li><code>insert</code>的返回值是指向新插入元素的迭代器</li>
<li>理解<code>emplace</code>：<code>c.emplace_back(&quot;978-0590353403&quot;, 25, 15.99)</code>等价于<code>c.push_back(Sales_data(&quot;978-0590353403&quot;, 25, 15.99))</code></li>
<li><code>emplace</code>在容器中直接构造元素。传递给<code>emplace</code>的参数必须与元素类型的构造函数相匹配。</li>
<li><code>front</code>和<code>back</code>分别返回首元素和尾元素的<strong>引用</strong>，注意区分其与<code>begin</code>和<code>end</code>的区别(后者是迭代器)</li>
<li>访问成员函数返回的是<strong>引用</strong>，如果容器是一个<code>const</code>对象，则返回值是<code>const</code>的引用；如果容器不是<code>const</code>的，则返回值是普通引用，我们可以用来改变元素的值</li>
<li>如果使用<code>auto</code>变量来保存和改变元素的值，必须将变量定义为引用类型</li>
<li>at和下标操作只适用于<code>string</code>、<code>vector</code>、<code>deque</code>和<code>array</code>，每个顺序容器都有一个<code>front</code>成员函数，除<code>forward_list</code>外所有顺序容器都有一个<code>back</code>成员函数。</li>
<li>删除<code>deque</code>中除首尾外的任何元素都会使迭代器、引用、指针失效；指向<code>vector</code>或<code>string</code>中删除点之后位置的迭代器、引用、指针都会失效</li>
<li><code>pop_front</code>和<code>pop_back</code>分别删除首元素和尾元素，<code>vector</code>和<code>string</code>不支持<code>pop_front</code>，<code>forward_list</code>不支持<code>pop_back</code></li>
<li><code>erase</code>可以删除由一个迭代器指定的单个元素，也可以删除由一对迭代器指定范围内的所有元素，返回指向删除元素之后位置的迭代器</li>
<li><code>forward_list</code>插入删除操作：<code>before_begin()</code>、<code>cbefore_begin()</code>返回指向链表首元素之前不存在的元素的迭代器(首前迭代器);<code>insert_after()</code>在迭代器p之后的位置插入元素;<code>emplace_after</code>使用args在p指定的位置后创建一个元素;<code>erase_after</code>删除p指向的位置后的元素</li>
<li>顺序容器改变大小:<code>c.resize(n)</code>、<code>c.resize(n,t)</code>;<code>vector</code>、<code>string</code>、<code>deque</code>进行<code>resize</code>可能导致迭代器、指针和引用失效，在缩小容器时指向被删除元素的迭代器、引用、指针会失效</li>
<li>由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此必须保证每次改变容器的操作之后都正确地重新定位迭代器，这对<code>vector</code>、<code>string</code>和<code>deque</code>尤为重要。</li>
<li>程序必须保证每个循环步中都更新迭代器、引用或指针，使用<code>insert</code>和<code>erase</code>是一个好的选择，因为它们会返回操作后的迭代器(分别指向新添加元素和删除元素之后)</li>
<li>不要<strong>保存</strong><code>end</code>返回的迭代器，而是反复调用它</li>
</ul>
<h3 id="vector对象是如何增长的">vector对象是如何增长的</h3>
<ul>
<li><code>vector</code>将元素连续存储，为了降低添加元素时所带来的内存分配和释放开销，<code>vector</code>和<code>string</code>会<strong>预分配更大的内存空间</strong>来避免内存空间的重新分配</li>
<li>管理容量的成员函数:<code>c.capacity()</code>-不重新分配内存空间的话c可以保存多少元素;<code>c.shrink_to_fit()</code>-将<code>capacity()</code>减少为与<code>size()</code>相同大小;<code>c.reserve(n)</code>-分配能容纳n个元素的内存空间</li>
<li>调用<code>reserve</code>永远不会减少容器占用的内存空间</li>
</ul>
<h3 id="额外的string操作">额外的string操作</h3>
<ul>
<li>构造string的其他方法:<code>string s(cp,n)</code>、<code>string s(s2,pos2)</code>、<code>string s(s2,pos2,len2)</code></li>
<li><code>s.substr(pos,n)</code>子字符串操作</li>
<li><code>string</code>还定义了额外的<code>insert</code>和<code>erase</code>版本(接受下标的版本):<code>s.insert(s.size(), 5, 'i');</code>、<code>s.erase(s.size()-5, 5);</code></li>
<li><code>string</code>还提供了接受C风格字符数组的<code>insert</code>和<code>assign</code></li>
<li></li>
</ul>
<h2 id="c特性">C++特性</h2>
<ul>
<li><strong><code>unique_ptr&lt;类型&gt;</code></strong></li>
</ul>
<p>代表一种不共享的指针，不能复制只能移动(<code>std::move</code>)，可以通过<code>make_unique&lt;类型&gt;(参数)</code>来创建。归属于头文件<code>&lt;memory&gt;</code>，属于C++标准库。</p>
<p>参考 <a href="https://docs.microsoft.com/en-us/cpp/cpp/how-to-create-and-use-unique-ptr-instances?view=msvc-160">How to: Create and use unique_ptr instances</a></p>
<ul>
<li><strong><code>inline</code></strong></li>
</ul>
<p>一种关键字，表示内联。在程序编译过程中对内联部分的代码调用直接替换代码段。仅适用于简单函数，仅对编译器进行建议，必须与实际实现的函数体放在一起才有意义（仅作用于声明则无效）。</p>
<p>参考 <a href="https://www.runoob.com/w3cnote/cpp-inline-usage.html">C++ 中的 inline 用法</a></p>
<ul>
<li><strong><code>const</code></strong></li>
</ul>
<p>一种关键字，表示常量。被修饰的对象或变量无法被修改。</p>
<p>const对象必须初始化，仅在文件内有效。</p>
<p>如果想在多个文件中共享const对象，必须在变量的定义之前添加<code>extern</code>关键字。</p>
<p>允许一个常量引用绑定非常量对象，但无法通过常量引用改变非常量对象。类似的，允许一个常量指针绑定非常量对象。</p>
<p>参考 <a href="https://docs.microsoft.com/en-us/cpp/cpp/const-cpp?view=msvc-160">const (C++)</a></p>
<ul>
<li><strong><code>constexpr</code></strong></li>
</ul>
<p>用来修饰编译器常量。由编译器来验证变量的值是否是一个常量表达式。</p>
<p>在C++ 11中，表示“常量”可以用constexpr，表示“只读”时才用const。</p>
<p>constexpr在修饰指针时仅对指针有效，与指针所指的对象无关。（将其定义的对象置为了顶层const）</p>
<ul>
<li><strong><code>memcpy</code></strong></li>
</ul>
<p><code>memcpy(a,b,c)</code>  从b处拷贝c个字节至a</p>
<p>属于标准库的cstring</p>
<ul>
<li><strong><code>override</code></strong></li>
</ul>
<p><code>override</code>关键字用于<em>派生类</em>中需要重写的函数后，如果这些函数未被重写，编译器会报错</p>
<p>防止直接继承基类成员函数的接口和缺省实现</p>

</div>



    
	
  



          </main>
        </div>
      </div>
      
<footer class="bg-dark py-5 row d-print-none">
  <div class="container-fluid mx-sm-5">
    <div class="row">
      <div class="col-6 col-sm-4 text-xs-center order-sm-2">
        
        
        
      </div>
      <div class="col-6 col-sm-4 text-right text-xs-center order-sm-3">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="GitHub" aria-label="GitHub">
    <a class="text-white" target="_blank" rel="noopener" href="https://github.com/Lowerce" aria-label="GitHub">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-12 col-sm-4 text-center py-2 order-sm-2">
        <small class="text-white">&copy; 2023 Lowerce 保留所有权利</small>
        
	
		<p class="mt-2"><a href="/about/">About Lowerce</a></p>
	
      </div>
    </div>
  </div>
</footer>


    </div>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"
    integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN"
    crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js"
    integrity="sha512-UR25UO94eTnCVwjbXozyeVd6ZqpaAE9naiEUBK/A+QDbfSTQFhPGj5lOR6d8tsgbBk84Ggb5A3EkjsOgPRPcKA=="
    crossorigin="anonymous"></script>





<script src='/js/tabpane-persist.js'></script>


















<script src="/js/main.min.ad402bfdb1ac8104d66668e601ee54c4f539eb3e53a1595e2755d0448cc75f6d.js" integrity="sha256-rUAr/bGsgQTWZmjmAe5UxPU56z5ToVleJ1XQRIzHX20=" crossorigin="anonymous"></script>




  </body>
</html>
